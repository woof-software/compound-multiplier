// SPDX-License-Identifier: MIT
pragma solidity =0.8.30;

import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import { CometFoundation } from "./CometFoundation.sol";
import { IComet } from "./external/compound/IComet.sol";
import { ICometExchange } from "./interfaces/ICometExchange.sol";
import { ICometStructs as ICS } from "./interfaces/ICometStructs.sol";
import { ICometAlerts as ICA } from "./interfaces/ICometAlerts.sol";
import { ICometEvents as ICE } from "./interfaces/ICometEvents.sol";

/**
 * @title CometCollateralSwap
 * @author WOOF! Software
 * @custom:security-contact dmitriy@woof.software
 *
 * @dev This contract allows users to swap one type of collateral for another in their Compound V3 position
 *      without needing to close their borrowing position. The process works by:
 *      1. Taking a flash loan of the desired collateral asset
 *      2. Supplying the flash loan to the user's Compound position
 *      3. Withdrawing the user's existing collateral
 *      4. Swapping the withdrawn collateral for the borrowed asset to repay the flash loan
 *      5. Supplying any remaining dust back to the user's position
 *
 *      The contract supports multiple flash loan providers through a modular plugin system and
 *      uses configurable swap plugins for executing the collateral swap.
 * @dev Features:
 *      - Multi-protocol flash loan support
 *      - Modular swap execution through dedicated swap plugins
 *      - Health factor validation to ensure position remains safe after swap
 *      - Gas-optimized execution using delegate calls and transient storage
 *      - Signature-based approvals for gasless transactions
 *      - Comprehensive slippage protection and validation
 * @dev Security Features:
 *      - Callback validation ensures only registered plugins can execute operations
 *      - Health factor checks prevent unsafe position modifications
 *      - Exact balance validation before and after operations
 *      - Transient storage prevents storage slot collisions
 *      - Comprehensive input validation and error handling
 * @dev Architecture:
 *      - Uses fallback() function as a universal callback handler for flash loan providers
 *      - Employs plugin pattern for extensibility and protocol abstraction
 *      - Integrates with allowBySig for meta-transaction support
 *      - Optimized for gas efficiency through minimal storage usage
 * @custom:security-considerations
 *      - Users must have sufficient collateral to maintain healthy positions after swaps
 *      - Flash loan fees are automatically accounted for in minimum output calculations
 *      - Slippage protection is enforced through minAmountOut parameter validation
 *      - Only registered and validated plugins can execute flash loans and swaps
 *      - Plugins are configured exclusively during contract deployment. To add or modify plugins,
 *        redeployment of the contract is required.
 */
contract CometCollateralSwap is CometFoundation, ICometExchange {
    using SafeERC20 for IERC20;

    constructor(ICS.Plugin[] memory _plugins) payable CometFoundation(_plugins) {}

    /**
     * @notice Handles flash loan callbacks from registered plugins to execute collateral swaps
     * @dev This fallback function is the core of the collateral swap mechanism. It receives callbacks
     *      from flash loan providers through registered plugins and executes a complete collateral swap:
     *      1. Validates the callback is from an authorized source
     *      2. Decodes the callback data and retrieves swap parameters
     *      3. Supplies the borrowed asset to Comet on behalf of the user
     *      4. Withdraws the user's collateral to be swapped
     *      5. Swaps the withdrawn collateral for the borrowed asset to repay the loan
     *      6. Supplies any remaining dust amounts back to the user
     *      7. Repays the flash loan with fees
     *
     * The function uses delegate calls to plugin endpoints for modularity and gas efficiency.
     * Temporary storage (tstore/tload) is used to pass swap parameters between function calls.
     *
     * @custom:security This function validates the caller is an authorized flash loan provider
     * @custom:security Uses tstore/tload for temporary parameter storage to avoid storage slot collisions
     * @custom:security Validates exact token balance requirements before and after operations
     * @custom:returns Returns uint256(1) to signal successful completion (required by some flash loan providers like AAVE)
     *
     * Requirements:
     * - msg.sig must correspond to a registered plugin callback selector
     * - msg.sender must be the registered flash loan provider for the callback selector
     * - The contract must receive exactly the expected amount of borrowed tokens
     * - The swap must produce enough tokens to repay the flash loan plus fees
     * - All delegate calls to plugins must succeed
     *
     * Reverts:
     * - UnknownPlugin: If the callback selector or sender is not recognized
     * - InvalidAmountOut: If token balances don't match expectations after operations
     * - May revert with plugin-specific errors if delegate calls fail
     */
    fallback() external {
        (
            uint256 snapshot,
            address loanPlugin,
            address swapPlugin,
            IComet comet,
            IERC20 fromAsset,
            uint256 fromAmount,
            address user,
            ICS.Mode mode
        ) = _tload();

        require(address(comet) != address(0), ICA.InvalidComet());

        (bool success, bytes memory payload) = loanPlugin.delegatecall(msg.data);
        _catch(success);

        ICS.CallbackData memory data = abi.decode(payload, (ICS.CallbackData));
        require(IERC20(data.asset).balanceOf(address(this)) == snapshot + data.debt, ICA.InvalidAmountOut());

        ICS.ProcessParams memory params = ICS.ProcessParams({
            supplyAsset: IERC20(data.asset),
            supplyAmount: data.debt,
            withdrawAsset: fromAsset,
            withdrawAmount: fromAmount
        });

        process(comet, user, params, data, loanPlugin, swapPlugin, mode);

        emit ICE.Swapped(address(comet), address(fromAsset), address(data.asset), fromAmount, 0);

        assembly {
            mstore(0x00, 1)
            return(0x00, 0x20)
        }
    }

    /*//////////////////////////////////////////////////////////////
                                EXTERNAL
    //////////////////////////////////////////////////////////////*/

    /// @inheritdoc ICometExchange
    function exchange(ICS.SwapParams calldata swapParams) external {
        _exchange(swapParams);
    }

    /// @inheritdoc ICometExchange
    function exchangeBySig(
        ICS.SwapParams calldata swapParams,
        ICS.AllowParams calldata allowParams
    ) external allow(swapParams.opts.comet, allowParams) {
        _exchange(swapParams);
    }

    /*//////////////////////////////////////////////////////////////
                                INTERNAL
    //////////////////////////////////////////////////////////////*/

    function _exchange(ICS.SwapParams calldata swapParams) internal {
        _validateSwapParams(swapParams);

        _tstore(
            swapParams.toAsset.balanceOf(address(this)),
            swapParams.opts.loanPlugin,
            swapParams.opts.swapPlugin,
            swapParams.opts.comet,
            swapParams.fromAsset,
            swapParams.fromAmount,
            msg.sender,
            ICS.Mode.COVER
        );

        _loan(
            swapParams.opts.loanPlugin,
            ICS.CallbackData({
                debt: swapParams.minAmountOut,
                fee: 0, // to be handled by plugin
                flp: address(0),
                asset: swapParams.toAsset,
                swapData: swapParams.swapCalldata
            })
        );
    }

    /**
     * @dev Checks if the collateralization is sufficient for the swap.
     * @param swapParams The parameters of the swap operation.
     *
     * @dev Liquidity is calculated based on comet implementation.
     * Implementation: https://github.com/compound-finance/comet/blob/main/contracts/Comet.sol#L544-L553
     */
    function _checkCollateralization(ICS.SwapParams calldata swapParams) internal view returns (bool) {
        IComet comet = swapParams.opts.comet;

        IComet.AssetInfo memory assetInfoFrom = comet.getAssetInfoByAddress(swapParams.fromAsset);
        IComet.AssetInfo memory assetInfoTo = comet.getAssetInfoByAddress(swapParams.toAsset);

        uint256 assetFromLiquidity = Math.mulDiv(
            Math.mulDiv(swapParams.fromAmount, comet.getPrice(assetInfoFrom.priceFeed), assetInfoFrom.scale),
            assetInfoFrom.borrowCollateralFactor,
            FACTOR_SCALE
        );

        uint256 assetInLiquidity = Math.mulDiv(
            Math.mulDiv(swapParams.minAmountOut, comet.getPrice(assetInfoTo.priceFeed), assetInfoTo.scale),
            assetInfoTo.borrowCollateralFactor,
            FACTOR_SCALE
        );

        return
            Math.mulDiv(assetFromLiquidity, (PRECISION - swapParams.maxHealthFactorDrop), PRECISION) <
            assetInLiquidity;
    }

    /**
     * @dev Validates swap parameters for correctness and safety
     * @param swapParams The swap parameters to validate
     */
    function _validateSwapParams(ICS.SwapParams calldata swapParams) private view {
        require(
            address(swapParams.fromAsset) != address(0) &&
                address(swapParams.toAsset) != address(0) &&
                swapParams.fromAsset != swapParams.toAsset &&
                swapParams.minAmountOut > 0 &&
                swapParams.maxHealthFactorDrop < PRECISION,
            ICA.InvalidSwapParameters()
        );

        _checkCollateralization(swapParams);
    }
}
