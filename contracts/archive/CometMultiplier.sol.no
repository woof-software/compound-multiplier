// SPDX-License-Identifier: MIT
pragma solidity =0.8.30;

import { AggregatorV3Interface } from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";
import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

import { IWEth } from "./external/weth/IWEth.sol";

import { CometFoundation } from "./CometFoundation.sol";
import { IComet } from "./external/compound/IComet.sol";
import { ICometMultiplier } from "./interfaces/ICometMultiplier.sol";
import { ICometStructs as ICS } from "./interfaces/ICometStructs.sol";
import { ICometAlerts as ICA } from "./interfaces/ICometAlerts.sol";
import { ICometEvents as ICE } from "./interfaces/ICometEvents.sol";

/**
 * @title CometMultiplier
 * @author WOOF! Software
 * @custom:security-contact dmitriy@woof.software
 * @notice A leveraged position manager for Compound V3 (Comet) markets that enables users to
 *         create and unwind leveraged positions using flash loans and token swaps
 * @dev This contract uses a plugin architecture to support different flash loan providers and DEX aggregators.
 *      It leverages transient storage (EIP-1153) for gas-efficient temporary data storage during operations.
 */
contract CometMultiplier is CometFoundation, ReentrancyGuard, ICometMultiplier {
    using SafeERC20 for IERC20;
    /// @notice Wrapped ETH (WETH) token address
    address public immutable wEth;

    /**
     * @notice Initializes the CometMultiplier with plugins and WETH address
     * @param _plugins Array of plugin configurations containing endpoints and their callback selectors
     * @param _wEth Address of the WETH token contract for handling ETH wrapping/unwrapping
     * @dev Each plugin must have a valid non-zero callback selector
     */
    constructor(ICS.Plugin[] memory _plugins, address _wEth) payable CometFoundation(_plugins) {
        require(_wEth != address(0), ICA.InvalidWeth());
        wEth = _wEth;
    }

    /**
     * @notice Handles flash loan callbacks from registered plugins
     * @dev This function is called by flash loan providers during the loan execution.
     *      It validates the callback, decodes the data, and routes to appropriate execution logic.
     * @custom:security This function uses delegatecall to plugin endpoints, ensuring they execute in this contract's context
     */
    fallback() external payable {
        (
            uint256 snapshot,
            address loanPlugin,
            address swapPlugin,
            IComet comet,
            IERC20 collateral,
            uint256 amount,
            address user,
            ICS.Mode mode
        ) = _tload();

        require(loanPlugin != address(0) && swapPlugin != address(0), ICA.UnknownPlugin());
        require(comet != IComet(address(0)), ICA.InvalidComet());

        (bool ok, bytes memory payload) = loanPlugin.delegatecall(msg.data);
        _catch(ok);

        ICS.CallbackData memory data = abi.decode(payload, (ICS.CallbackData));

        require(data.asset.balanceOf(address(this)) >= snapshot + data.debt, ICA.InvalidAmountOut());

        ICS.ProcessParams memory params;
        if (mode == ICS.Mode.MULTIPLY) {
            params = ICS.ProcessParams({
                supplyAsset: collateral,
                supplyAmount: amount,
                withdrawAsset: data.asset,
                withdrawAmount: data.debt + data.fee
            });
        } else {
            params = ICS.ProcessParams({
                supplyAsset: data.asset,
                supplyAmount: data.debt,
                withdrawAsset: collateral,
                withdrawAmount: amount
            });
        }

        process(comet, user, params, data, loanPlugin, swapPlugin, mode);

        assembly {
            mstore(0x00, 1)
            return(0x00, 0x20)
        }
    }

    /**
     * @inheritdoc ICometMultiplier
     */
    function multiply(
        ICS.Options calldata opts,
        IERC20 collateral,
        uint256 collateralAmount,
        uint256 leverage,
        bytes calldata swapData
    ) external payable nonReentrant {
        _multiply(opts, collateral, collateralAmount, leverage, swapData);
    }

    /**
     * @inheritdoc ICometMultiplier
     */
    function multiplyBySig(
        ICS.Options calldata opts,
        IERC20 collateral,
        uint256 collateralAmount,
        uint256 leverage,
        bytes calldata swapData,
        ICS.AllowParams calldata allowParams
    ) external payable nonReentrant allow(opts.comet, allowParams) {
        _multiply(opts, collateral, collateralAmount, leverage, swapData);
    }

    /**
     * @inheritdoc ICometMultiplier
     */
    function cover(
        ICS.Options calldata opts,
        IERC20 collateral,
        uint256 collateralAmount,
        bytes calldata swapData
    ) external nonReentrant {
        _cover(opts, collateral, collateralAmount, swapData);
    }

    /**
     * @inheritdoc ICometMultiplier
     */
    function coverBySig(
        ICS.Options calldata opts,
        IERC20 collateral,
        uint256 collateralAmount,
        bytes calldata swapData,
        ICS.AllowParams calldata allowParams
    ) external nonReentrant allow(opts.comet, allowParams) {
        _cover(opts, collateral, collateralAmount, swapData);
    }

    /**
     * @notice Internal implementation of multiply
     */
    function _multiply(
        ICS.Options calldata opts,
        IERC20 collateral,
        uint256 collateralAmount,
        uint256 leverage,
        bytes calldata swapData
    ) internal {
        IComet comet = opts.comet;
        require(address(comet) != address(0), ICA.InvalidComet());

        if (msg.value > 0) {
            require(address(collateral) == wEth, ICA.InvalidWeth());
            collateralAmount = msg.value;
            IWEth(wEth).deposit{ value: msg.value }();
        } else {
            collateral.safeTransferFrom(msg.sender, address(this), collateralAmount);
        }

        IERC20 baseAsset = comet.baseToken();
        address loanPlugin = opts.loanPlugin;

        _tstore(
            baseAsset.balanceOf(address(this)),
            loanPlugin,
            opts.swapPlugin,
            comet,
            collateral,
            collateralAmount,
            msg.sender,
            ICS.Mode.MULTIPLY
        );

        _loan(
            loanPlugin,
            ICS.CallbackData({
                debt: _leveraged(comet, collateral, collateralAmount, leverage),
                fee: 0, // to be handled by plugin
                flp: address(0), // to be handled by plugin
                asset: baseAsset,
                swapData: swapData
            })
        );
    }

    /**
     * @notice Internal implementation of cover
     */
    function _cover(
        ICS.Options calldata opts,
        IERC20 collateral,
        uint256 collateralAmount,
        bytes calldata swapData
    ) internal {
        IComet comet = opts.comet;
        require(address(comet) != address(0), ICA.InvalidComet());

        uint256 repayAmount = comet.borrowBalanceOf(msg.sender);
        require(repayAmount > 0, ICA.NothingToDeleverage());

        uint256 loanDebt;
        if (collateralAmount == type(uint256).max) {
            loanDebt = repayAmount;
            collateralAmount = comet.collateralBalanceOf(msg.sender, collateral);
        } else {
            require(collateralAmount <= comet.collateralBalanceOf(msg.sender, collateral), ICA.InvalidAmountIn());
            loanDebt = Math.min(_convert(comet, collateral, collateralAmount), repayAmount);
        }
        require(loanDebt > 0, ICA.InvalidLeverage());

        IERC20 baseAsset = comet.baseToken();

        _tstore(
            baseAsset.balanceOf(address(this)),
            opts.loanPlugin,
            opts.swapPlugin,
            comet,
            collateral,
            collateralAmount,
            msg.sender,
            ICS.Mode.COVER
        );

        _loan(
            opts.loanPlugin,
            ICS.CallbackData({
                debt: loanDebt,
                fee: 0, // to be handled by plugin
                flp: address(0), // to be handled by plugin
                asset: baseAsset,
                swapData: swapData
            })
        );
    }

    /**
     * @notice Calculates the required loan amount for a given leverage ratio
     * @param comet The Comet comet interface
     * @param collateral Address of the collateral token
     * @param collateralAmount Amount of collateral being supplied
     * @param leverage Leverage multiplier (e.g., 20000 = 2x)
     * @return Required loan amount in base asset terms
     * @dev Formula: loan = (initialValue * (leverage - 1)) / PRECISION
     */
    function _leveraged(
        IComet comet,
        IERC20 collateral,
        uint256 collateralAmount,
        uint256 leverage
    ) private view returns (uint256) {
        IComet.AssetInfo memory info = comet.getAssetInfoByAddress(collateral);

        return
            // leveraged collateral value in base asset
            Math.mulDiv(
                // collateral value in base asset
                Math.mulDiv(
                    Math.mulDiv(
                        collateralAmount,
                        comet.getPrice(info.priceFeed),
                        10 ** AggregatorV3Interface(info.priceFeed).decimals()
                    ),
                    comet.baseScale(),
                    info.scale
                ),
                leverage - PRECISION,
                PRECISION
            );
    }

    /**
     * @notice Converts between collateral and base asset amounts using comet prices
     * @param comet The Comet comet interface
     * @param collateral Address of the collateral token
     * @param collateralAmount Amount to convert
     * @return Converted amount in the target denomination
     * @dev Accounts for collateral factors and price feed decimals in conversions
     */
    function _convert(IComet comet, IERC20 collateral, uint256 collateralAmount) private view returns (uint256) {
        IComet.AssetInfo memory info = comet.getAssetInfoByAddress(collateral);
        address priceFeed = info.priceFeed;

        uint256 num = comet.getPrice(priceFeed) * comet.baseScale() * uint256(info.borrowCollateralFactor);
        uint256 den = (10 ** AggregatorV3Interface(priceFeed).decimals() * info.scale) * FACTOR_SCALE;

        return Math.mulDiv(collateralAmount, num, den);
    }
}
